#include "Melody.h"
#include "Composer.h"
#include "Note.h"
#include <iostream>
#include <fstream>
#include <vector>
#include <utility>
#include <cstdlib>
#include <ctime>
#include <math.h>

using namespace std;

/*
Input: num - the number in MIDI form to be transformed into its musical counterpart.
Output: the note that the number refers to

Takes a number in and searchs through the vector that contains possible notes.

*/


string Melody::charToNote(int num, Note &n){
	//vector<char> allNotes;
	string note=" ";
	if(num>11) //if the number is greater than eleven then we lower it since the vector only has 12 spots
		num = num % 12;
	while(num<0){ //if the number is less than 0 we keep adding 12 (octave) until it does
		num+=12;
	}
		
	n.addAllNotes();
	for(int i=0;i<n.allNotes.size();i++){  //searches through the vector until it finds the spot that correpsonds to the number
		if(num==i)
			return n.allNotes[i];
			
	}
		
}

/*
Input: possibleMelodies - deque which contains all the melodies generated by the AI
Output: bestMelody - the melody with the highest score given

Take in all the melodies and their scoresand finds the one with the highest score
and returns it as the melody to be played

*/

vector <char> Melody::chooseBestMelody(deque <Melody> possibleMelodies){
	vector <char> bestMelody = possibleMelodies[0].measure;  //sets the beginning as the highest
	int highScore = possibleMelodies[0].points; 			//for the time being
	
	for(int i=1;i<possibleMelodies.size();i++){
		if(possibleMelodies[i].points>highScore){
			bestMelody = possibleMelodies[i].measure;  //if it finds a higher score then it will set the
			highScore = possibleMelodies[i].points;   //that melodiy as the best
		}
	}

	return bestMelody;
}

/*
Input: a - the current melody being scored for its tonic note
n - instance of the note class
Output: tonicScore - the number of times multiplied by 10 of how many times the tonic note was 
found

Looks through the melody and calculates how many times it found the tonic note

*/

int Melody::scoreTonicNote(vector <char> a, Note &n){
	int tonicScore=0;
	for(int i=0;i<a.size();i++){
		if(a[i]!=99){
			if((string)charToNote(a[i],n)==n.getTonicNote())
				tonicScore+=30;//if found then it adds 30 to the score
		}
	}
	return tonicScore;
}

/*
Input: a - the current melody being scored for its tonic note
c - instance of the Composer class
Output: numberOfNotes - the score of how many times it found notes in the scale

Looks through the melody and calculates how many notes in the key signature it found 

*/

int Melody::scoreNumberOfNotesInScale(vector <char> a, Composer &c, Note &n){
	int numberOfNotes=0;

	for(int x=0;x<a.size();x++){
		for(int y=0;y<c.notesInKey.size();y++){
			if(a[x]!=99){
				if((int)a[x]>11){
					a[x] = (int)a[x] % 12;  //some notes have a higher number than the size of the file
					//in order to compensate then we find the mod which will lower it to the correct number
					// C = 12, 12 mod 12 = 0 and 0 is also C but just a lower pitch 
				}
				if((int)a[x]==(int)c.notesInKey[y]){
					numberOfNotes+=5;
					break;
				}		
			}
		}
	}
	
	return numberOfNotes;
}

/*
Input: a - the current melody being scored for its tonic note

Output: numberOfSteps - the score of how the total number of steps and skips there are in between notes

A step is when a note goes to the next note in the scale.
Ex. C major: C D E F G A B C
A step from C would be D in a melody.

A skip is anything larger than a step.
Ex. C major: C D E F G A B C
A skip from C would be E, F, G, A, B, or C in a melody.

*/

int Melody::findNumberOfSteps(vector <char> a){
	int numberOfSteps=0;
	char previousNote=' ';
	char currentNote=' ';
	previousNote=a[0];  //sets the previous note as the first note
	
	for(int i=1;i<a.size();i++){
		if(a[i]!=99){
			currentNote=a[i];  //when it finds the next note, it will make that the new note
			int num = currentNote-previousNote;
			if(num < 0)  //if the amount is negative then make it positive so it makes the scoring easier
				num*=-1;
			if(num>7) //if the amount between notes is too big then it will make the melody less likely to be picked
				numberOfSteps+=num;  //adds the difference to the score
			else if(num==0)
				numberOfSteps+=5;  //if there is a note that stays the same then it will not be as 
				//nice of a melody 
			previousNote=a[i];  //sets the previous note as the current note
		}
	}
	
	return numberOfSteps;
}

/*
Input: e - vector containing the rhythm 
filename - file to write to
output: void

Prints out the rhythm to see what is happening

*/
void Melody::regularPrint(vector<char> e, string fileName){
	
	ofstream file;
  	file.open (fileName.c_str(), std::ios_base::app);
  	
  	file<<"[";
	for(int i=0;i<e.size();i++){
		file<<e[i]<<"  ";  //outputs the rhythm element
	}
	file<<"]"<<endl;
	file<<endl;
	file<<endl;
	file<<endl;
}

/*
Input: e - vector containing the melody
filename - file to write to
score - the score given to the melody by the scoring methods
n - instance of Note class
output: void

Prints out every melody along with their scores to a text file

*/

void Melody::printMelody(vector<char> e, string fileName, int score, Note &n){
	
	ofstream file;
  	file.open (fileName.c_str(), std::ios_base::app);
  	file<<"[";
	for(int i=0;i<e.size();i++){
		if(e[i] != 99)  //if the element is a note then it converts to a note letter
			file<<charToNote(e[i],n)<<" , ";
		else
			file<<e[i]<<" , ";  //otherwise it prints out c
	}
	file<<"]"<<"  score: "<<score<<endl;
	file<<endl;
	file<<endl;
	file<<endl;
}

/*
Input: leftHand - vector which contains the melody or the bass to be printed out
n - note class instance
filename - name of the file

Output: void

Prints out the vector containing the note numbers and 99's to the file "score.txt"
Translates the number into the musical note and counts up the number of 99's until the next note
Then it translates those 99's into a musical note.

Ex.
<C , Q >, <Eb , H >, <D , 

*/

void Melody::print(vector<char> leftHand, Note &n, string fileName){
	
	ofstream myfile;
  	myfile.open (fileName.c_str(), std::ios_base::app);

	int numOf99s=0;
	for(int i=0;i<leftHand.size();i++){
		if(leftHand[i]==99)
			numOf99s++;  //if it finds a 99 then it adds one to keep track of them
	
		else{
			if(numOf99s==1){  //one 99 between two notes means the first note is an eighth note
				myfile<<n.getEighthNoteChar()<<" >"<<", ";
				numOf99s=0;
			}
			else if(numOf99s==3){ //three 99's between two notes means the first note is a quarter note
				myfile<<n.getQuarterNoteChar()<<" >"<<", ";
				numOf99s=0;
			}	
			else if(numOf99s==7){  //seven 99's between two notes means the first note is a half note
				myfile<<n.getHalfNoteChar()<<" >"<<", ";
				numOf99s=0;
			}
			else if(numOf99s==15){  //fifteen 99's between two notes means the first note is a whole note
				myfile<<n.getWholeNoteChar()<<" >"<<", ";
				numOf99s=0;
			}
			myfile<<"< "<<charToNote((int)leftHand[i],n)<<" : ";	
					
		}
	}
	
	if(numOf99s==1) //finishes up the very end of the melody
		myfile<<"E"<<" >";   //the while loops does not finish it completely
	else if(numOf99s==3)
		myfile<<"Q"<<" >";
	else if(numOf99s==7)
		myfile<<"H"<<" >";
	else if(numOf99s==15)
		myfile<<"W"<<" >";	
			
	myfile<<endl;  //creates a space between the left and right hands
	myfile<<endl;
	myfile<<endl;
	myfile<<endl;
	myfile.close();
			
}

/*
Input: leftHand - vector which contains the melody or the bass to be printed out
n - note class instance

Output: void

Prints out the vector containing the note numbers and 99's to the file "score.txt"
Translates the number into the musical note and counts up the number of 99's until the next note
Then it translates those 99's into a musical note.

Ex.
<C, E, G : Q >

*/

void Melody::printChords(vector<char> leftHand, Composer &c, Note &n, string fileName){
	ofstream myfile;
  	myfile.open (fileName.c_str(), std::ios_base::app);

	int numOf99s=0;
	for(int i=0;i<leftHand.size();i++){
		if(leftHand[i]==99)
			numOf99s++;

		else{
			while(numOf99s!=0){
				if(numOf99s>=15){  //one 99 between two notes means the first note is an eighth note
					myfile<<n.getWholeNoteChar();
					numOf99s-=15;
				}
				else if(numOf99s>=7){ //three 99's between two notes means the first note is a quarter note
					myfile<<n.getHalfNoteChar();
					numOf99s-=7;
				}	
				else if(numOf99s>=3){  //seven 99's between two notes means the first note is a half note
					myfile<<n.getQuarterNoteChar();
					numOf99s-=3;
				}
				else if(numOf99s>=1){  //fifteen 99's between two notes means the first note is a whole note
					myfile<<n.getEighthNoteChar();
					numOf99s-=1;
				}
				if(numOf99s!=0)  //if there still exist more 99s then add a plus to concatenate notes 
					myfile<<"+";
				else
					myfile<<" >, ";  //finishes up the note
			}
			
			myfile<<"< ";  //starts the first or next note in the score
			
			for(int j=0;j<3;j++){
				myfile<<charToNote((int)c.possibleChords[leftHand[i]][j],n)<<" , ";	//loops through the
				//char which create the chord and writes out the strings correpsonding to those chars
			}
			
			myfile<<" : ";	//separates the notes from the length	
		}
	}
	
	myfile<<" >";
	
	while(numOf99s!=0){
				if(numOf99s>=15){  //one 99 between two notes means the first note is an eighth note
					myfile<<n.getWholeNoteChar();
					numOf99s-=15;
				}
				else if(numOf99s>=7){ //three 99's between two notes means the first note is a quarter note
					myfile<<n.getHalfNoteChar();
					numOf99s-=7;
				}	
				else if(numOf99s>=3){  //seven 99's between two notes means the first note is a half note
					myfile<<n.getQuarterNoteChar();
					numOf99s-=3;
				}
				else if(numOf99s>=1){  //fifteen 99's between two notes means the first note is a whole note
					myfile<<n.getEighthNoteChar();
					numOf99s-=1;
				}
				myfile<<"+"; //used to concatenate notes and create other lengths that do not exist in the program
			}
				myfile<<" >";

	myfile<<endl;  //creates a space between the left and right hands
	myfile<<endl;
	myfile<<endl;
	myfile<<endl;
	myfile.close();
	
}
/*
input: note - the previous being built upon for the passing note
output: note - the new note made

This function is used when there is a note in the melody but not one in the bass that matches up with it
It selects a number which corresponds to it going up, down or staying.  Less than or equal to 2 means it will go
up the scale, more than or equal to 4 will mean it goes down, and at 3 means it will stay at that note; since
we don't want too many notes staying at the same note for too long.

Ex.				
Right	Bb c D c Eb
			 ^--- Passing note
Left	Eb c c c Eb	
			

*/

char Melody::addPassingNote(char note){
	
	int step = rand() % 6 + 0;  //determies if the note should go up, down or stay
	int amount = rand() % 4 + 1;
	if(step<=2)  //create a higher pitched note from the previous one
		note+=(2*amount);
	else if(step>=4) //create a lower pitched note from the previous one
		note-=(2*amount);
		//otherwise keep it the same
		
	return note;
}
/*
input: note - the note in the bassline
output: consNotes - possible notes to combine with the bassline note

This function is used to help create a more consonant/stable sound between two notes being at
the same time.  If we chose any random note then there is a chance that note would cause 
dissonance/unstability in the sound.


*/

vector<char> Melody::developConsonantNotes(char note){
	vector<char> consNotes;
	consNotes.push_back(note);
	note+=4;  //creates a major 3rd
	consNotes.push_back(note);
	note+=1; //creates a perfect 4th
	consNotes.push_back(note);
	note+=2; //creates a perfect fifth
	consNotes.push_back(note);
	note+=5; //creates a perfect octave
	consNotes.push_back(note);
	
	return consNotes;
}

/*
input: rightHand - vector holding the rhythm of the melody
leftHand - vector holding the melody of the bassline
n - instance of the Note class 
c - instance of the Composer class
output: returns the melody chosen from the bestMelody function

This looks at the bassline and finds the first note and then marks the spot where it is.  Next it does the
same with the melody and searches for the note in the same spot that it found the note in the bassline.
If there isn't one then it skips it otherwise it creates four possible notes from the consonantNote function
and then chooses one at random.  If there is a note before it reaches the spot then it makes that note a 
passing note and creates it own note from scratch.  It does this 5,000 times in order to max out the possibility
of all notes being used.  Afterwards it scores all the melody and picks the best one. 

*/

vector<char> Melody::developMelody(vector<char> rightHand, vector<char> leftHand, Note &n, Composer &c){

	srand (time(NULL));
	
	for(int i=0;i<2000;i++){
		
		int leftHandMarker=0;  //marks the spot that a note is in the bassline
		int rightHandMarker=0; //marks the spot that a note is in the melody
		char currentNote=' '; //currentNote is the note being used in the bassline to help create notes in the melody
		char pastNote=' '; //used for the passingNote function
		
		Melody m2;  //creates a new instance of the Melody class
		m2.measure=rightHand;  //sets the measure portion equal to the rhythm of the rightHand
		
		while(leftHandMarker < leftHand.size()){  //continues this until the leftMarker reaches
		//the end of the vector
			
		for(int i=leftHandMarker;i<leftHand.size();i++){
			
			if(leftHand[leftHandMarker]==99){  //if it finds a 99 then it adds to the leftHandMarker value
				leftHandMarker++; 
			}
			
			else{
				currentNote=leftHand[leftHandMarker];  //otherwise it will set the note it finds to the currentNote
				break;
			}
		}
		
		vector<char> consNotes = developConsonantNotes(currentNote);  //holds all notes that will sound the best with the bass note
		pastNote = currentNote;
		
		for(int j=rightHandMarker+1;j<leftHandMarker;j++){//loops through the vector from it's original place to the spot where the 
			if(m2.measure[j] != 99){ //bassline stopped and checks if there are any other notes in between that do not need a 
				char newNote = addPassingNote(pastNote);//specific value
				m2.measure[j] = newNote;
				pastNote = newNote;
			}
		}
		
		if(leftHandMarker >= leftHand.size()) //if the leftHandMarker is has passed the size of the vector
			break; //then it breaks out of the loop
					
		int e = rand() % consNotes.size() + 0;  //chooses a random note from the size of the vector to the beginning
		
		if(m2.measure[leftHandMarker]!=99)
			m2.measure[leftHandMarker] = consNotes[e];	//if there is no note then skips the function since is no need
		
		pastNote = m2.measure[leftHandMarker];
		rightHandMarker = leftHandMarker;  //makes the rightHandMarker equal to the leftHandMarker
		//so it starts out at the part at the beginning of the function
		leftHandMarker++; //add one so it does not start at the same note again

		}
		
		m2.points = 0;
		m2.points+=scoreTonicNote(m2.measure, n);  //scores the amount of tonic notes
		m2.points+=scoreNumberOfNotesInScale(m2.measure, c, n);//scores the amount of notes in the key
		m2.points-=findNumberOfSteps(m2.measure); //scores the amount of total steps between notes
		
		printMelody(m2.measure,"melody evol.txt",m2.points,n);
		
		possibleMelodies.push_back(m2);
	}
	
	return chooseBestMelody(possibleMelodies);

}

/*
input: rightHand - vector holding the rhythm of the melody
leftHand - vector holding the melody of the bassline
n - instance of the Note class 
c - instance of the Composer class
output: returns the melody chosen from the bestMelody function

This is the same of the previous function except it deals with chords.  It also chooses from the numbers
in the chord as the notes in the melody. Other than this, everything else is the same

*/

vector<char> Melody::developMelodyWithChords(vector<char> rightHand, vector<char> leftHand, Note &n, Composer &c){

	srand (time(NULL));
	
	for(int i=0;i<2000;i++){
		
		int leftHandMarker=0;
		int rightHandMarker=0;
		char currentNote=' ';
		char pastNote=' ';
		
		Melody m2;
		m2.measure=rightHand;
		
		while(leftHandMarker < leftHand.size()){
			
		for(int i=leftHandMarker;i<leftHand.size();i++){
			
			if(leftHand[leftHandMarker]==99){
				leftHandMarker++;
			}
			
			else{
				currentNote=leftHand[leftHandMarker];
				break;
			}
		}
			
		vector<char> consNotes;
		
		for(int i=0;i<3;i++)
			consNotes.push_back(c.possibleChords[(int)currentNote][i]);//looks through the notes 
			//and pushes them into the consonant notes vector
		
		pastNote = currentNote;
		
		for(int j=rightHandMarker+1;j<leftHandMarker;j++){
			if(m2.measure[j] != 99){
				char newNote = addPassingNote(pastNote);
				m2.measure[j] = newNote;
				pastNote = newNote;
			}
		}
		
		if(leftHandMarker >= leftHand.size())
			break;	
				
		int e = rand() % consNotes.size() + 0;
		
		if(m2.measure[leftHandMarker]!=99)  //adds one of the notes from the vector to the melody
			m2.measure[leftHandMarker] = consNotes[e];
				
		pastNote = m2.measure[leftHandMarker];
		rightHandMarker = leftHandMarker;
		leftHandMarker++;  //adds one so it does not start from the note it left from

		}
		
		m2.points = 0;
		m2.points+=scoreTonicNote(m2.measure, n);
		m2.points+=scoreNumberOfNotesInScale(m2.measure, c, n);
		m2.points-=findNumberOfSteps(m2.measure);
		
		printMelody(m2.measure, "melody evol.txt", m2.points, n);
		
		possibleMelodies.push_back(m2);
	}
	
	return chooseBestMelody(possibleMelodies);

}

/*
Input: temp -  the vector containing the rhythm
top - the top note of the time signature
bottom - the bottom note of the time signature
Output: false if a bad rhythm and true otherwise

Uses the top and bottom numbers to see if the rhythm is good enough
Otherwise it returns false and it is sent to the divideNotes function

*/

bool Melody::goodRhythm(vector<char> temp, int top, int bottom){
	
	if(bottom==8){
		if(temp.size() < top-1) //due to the nature of being in 8 any melody that is slightly below the maount in the top is fine
			return false;
		else
			return true;
	}
		
	else if(bottom==2){
		if(temp.size() < top+5)  //if the number of notes is less than the amount in the top+5 then it repeats the division
			return false;
		else
			return true;
	}
	else if(bottom==4){
		if(temp.size() < top+5 && temp.size() > top)  //if the number of notes is less than the amount in the top then it repeats the division
			return true;
		else
			return false;
	}
}
/*
Input: score -  the vector containing the rhythm
top - the top note of the time signature
bottom - the bottom note of the time signature
Output: score

Chooses a random note in the rhythm and divides it into two notes in order to
increase it likelyhood of being chosen next time.  If it fails again, it repeats the same thing
again.

*/

vector<char> Melody::divideNotes(vector<char> score, int top, int bottom){
	int decide;
	bool b;
	
	while(b != true){
		decide = rand() % score.size() + 0;
		
		if(score[decide]=='W'){ //a whole note can divide into two half notes
			score.erase(score.begin()+decide);
			score.insert(score.begin()+decide,'H');
			score.insert(score.begin()+decide,'H');
		}
		else if(score[decide]=='H'){ //a half note can divide into two quarter notes
			score.erase(score.begin()+decide);
			score.insert(score.begin()+decide,'Q');
			score.insert(score.begin()+decide,'Q');
		}
		else if(score[decide]=='Q'){ //a quarter note can divide into two eighth notes
			score.erase(score.begin()+decide);
			score.insert(score.begin()+decide,'E');
			score.insert(score.begin()+decide,'E');
		} 
		//an eighth dividing into two 16th notes is out of the scope of this project
		if(score[decide]!='E')
			regularPrint(score,"rhythm evolution.txt");
		
		b=goodRhythm(score,top,bottom);
		
		
	}
	return score;
}
